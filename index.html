<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Load Duration Curve (Colored Zones)</title>
  <script src="https://code.highcharts.com/highcharts.js"></script>
  <script src="mapping.js"></script>
  <style>
    body { font-family:Arial, sans-serif; margin:2rem; text-align:center }
    #curve_div { width:100%; max-width:900px; height:500px; margin:0 auto }
  </style>
</head>
<body>
  <h2>Load Duration Curve (Last 30 Days, 15-min)</h2>
  <div id="curve_div">Loading…</div>

  <script>
    // — your existing fetchSeries(...) here (same as before) —
    async function fetchSeries(entry) {
      const now  = new Date();
      const from = new Date(now - 30*24*3600*1000);
      const body = {
        query: `
          query($ds:String!,$name:String!,$from:String!,$to:String!,
                $agg:MetricDataAggregationMethod!,$window:String!,$samplingWindow:String!) {
            dataPoint(dataSourceName:$ds,name:$name){
              data(from:$from, to:$to,
                   aggregation:$agg, window:$window,
                   samplingWindow:$samplingWindow){
                nodes { time data }
              }
            }
          }
        `,
        variables:{
          ds:            entry.dataSourceName,
          name:          entry.metricName,
          from:          from.toISOString(),
          to:            now.toISOString(),
          agg:           "LAST",
          window:        "15 minutes",
          samplingWindow:"15 minutes"
        }
      };
      const resp = await fetch('https://sankey-proxy.onrender.com/api/graphql',{
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify(body)
      });
      const json  = await resp.json();
      const nodes = json?.data?.dataPoint?.data?.nodes||[];
      return nodes.map(n=>[ Date.parse(n.time), n.data ]);
    }

    async function drawDurationCurve() {
      // 1) get the two mains
      const elec = sankeyMapping.find(e=>e.system==="Main Electric");
      const gas  = sankeyMapping.find(e=>e.system==="Main Gas");

      // 2) fetch both series
      const [sE, sG] = await Promise.all([ fetchSeries(elec), fetchSeries(gas) ]);

      // 3) sum them into a lookup
      const sumMap = {};
      sE.forEach(([t,v])=> sumMap[t]=(sumMap[t]||0)+v);
      sG.forEach(([t,v])=> sumMap[t]=(sumMap[t]||0)+v);

      // 4) extract & sort descending
      const sorted = Object.values(sumMap).sort((a,b)=>b-a);

      // 5) prepare the duration-curve points [percent, demand]
      const n = sorted.length;
      const pts = sorted.map((v,i)=>[
        parseFloat(((i/(n-1))*100).toFixed(2)),
        parseFloat(v.toFixed(2))
      ]);

      // 6) define your thresholds:
      //    e.g. baseload = bottom 10% demand, peaking = top 5% demand 
      //    (you can calculate these dynamically too)
      const baseloadThreshold     = sorted[Math.floor(n)]; // last point
      const peakingThreshold      = sorted[Math.floor(n*0.05)]; // 5% point

      // 7) draw as an AREA with zones on the Y axis:
      Highcharts.chart('curve_div', {
        chart: { type: 'area' },
        title: { text: '' },
        xAxis: {
          title: { text: 'Percent of Time (%)' },
          min: 0, max: 100
        },
        yAxis: {
          title: { text: 'Combined Load Demand' }
        },
        tooltip: {
          headerFormat: '',
          pointFormat: '<b>{point.y:.1f}</b> at {point.x:.2f}%'
        },
        plotOptions: {
          series: {
            zoneAxis: 'y',
            zones: [
              { value: baseloadThreshold, color: '#c0392b' },   // red
              { value: peakingThreshold,  color: '#27ae60' },   // green
              {                    color: '#8e44ad' }            // purple
            ],
            fillOpacity: 0.7,
            marker: { enabled: false }
          }
        },
        series: [{
          name: 'Load Duration',
          data: pts,
          showInLegend: false
        }],
        credits: { enabled: false }
      });
    }

    document.addEventListener('DOMContentLoaded', drawDurationCurve);
  </script>
</body>
</html>
